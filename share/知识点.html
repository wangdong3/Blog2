<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>知识点 | 文档管理</title>
    <meta name="description" content="文档管理">
    
    
    <link rel="preload" href="/blog/assets/css/0.styles.d0c45ef5.css" as="style"><link rel="preload" href="/blog/assets/js/app.3e99f69d.js" as="script"><link rel="preload" href="/blog/assets/js/2.1d01ac6d.js" as="script"><link rel="preload" href="/blog/assets/js/24.cca64a4b.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.f5b859e5.js"><link rel="prefetch" href="/blog/assets/js/11.b37e8187.js"><link rel="prefetch" href="/blog/assets/js/12.9889c9d8.js"><link rel="prefetch" href="/blog/assets/js/13.ed0f9110.js"><link rel="prefetch" href="/blog/assets/js/14.05748518.js"><link rel="prefetch" href="/blog/assets/js/15.47cd0f13.js"><link rel="prefetch" href="/blog/assets/js/16.cb844129.js"><link rel="prefetch" href="/blog/assets/js/17.ac47ed2d.js"><link rel="prefetch" href="/blog/assets/js/18.fe9088bd.js"><link rel="prefetch" href="/blog/assets/js/19.64dec7e8.js"><link rel="prefetch" href="/blog/assets/js/20.6fce1f9f.js"><link rel="prefetch" href="/blog/assets/js/21.f5e1e54f.js"><link rel="prefetch" href="/blog/assets/js/22.8c07f2e7.js"><link rel="prefetch" href="/blog/assets/js/23.37e8ce6a.js"><link rel="prefetch" href="/blog/assets/js/25.ab895184.js"><link rel="prefetch" href="/blog/assets/js/26.a49d3732.js"><link rel="prefetch" href="/blog/assets/js/27.e28f9ecd.js"><link rel="prefetch" href="/blog/assets/js/3.95ec7ebd.js"><link rel="prefetch" href="/blog/assets/js/4.61334da3.js"><link rel="prefetch" href="/blog/assets/js/5.82ac8d76.js"><link rel="prefetch" href="/blog/assets/js/6.491b24b7.js"><link rel="prefetch" href="/blog/assets/js/7.3c1d5c8e.js"><link rel="prefetch" href="/blog/assets/js/8.560c0130.js"><link rel="prefetch" href="/blog/assets/js/9.cd94200d.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.d0c45ef5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="文档管理" class="logo"> <span class="site-name can-hide">文档管理</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/share/" class="nav-link router-link-active">Share</a></div><div class="nav-item"><a href="http://blog.csdn.net" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/wangdong3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/share/" class="nav-link router-link-active">Share</a></div><div class="nav-item"><a href="http://blog.csdn.net" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/wangdong3" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ElasticSearch</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>知识点</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/share/知识点.html" class="active sidebar-link">知识点</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="content default"><h1 id="知识点">知识点</h1> <h2 id="一、计算机基础">一、计算机基础</h2> <p><strong>机器数: 原码 补码 反码</strong></p> <blockquote><p>练习： [x]补=1 1110100， [y]补=10110000。若整型变量 z=2*x+y/2，则 z 的机器数为（ ）。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>第一步：根据补码算反码（正数的补码与其原码相同；负数的补码是在其反码的末位加1）

反码: x: 11110011   y: 10101111

第二步：根据反码算原码（正数的反码与其原码相同；负数的反码是对其原码逐位取反，符号位除外）

原码: x: 10001100   y: 11010000

第三步：分别计算2*x和y/2

10001100 向左移一位
2*x =  10011000

11010000  向右移一位
y/2 = 10101000

第四步：计算2*x+y/2

10011000
+  10101000

z=2*x+y/2 = 11000000


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h2 id="二、java基础">二、Java基础</h2> <p><strong>1.String</strong> :</p> <pre><code>1.String常量池：字符串常量放在常量池中实现复用，指向常量池中同一个内存地址；

2.为什么String是不可变的：成员变量final，并且没有set方法来修改
</code></pre> <p><strong>2.new</strong>：</p> <pre><code>创建新的对象，指向全新的内存地址；

String类的intern方法创建返回一个常量池中的固定对象
</code></pre> <p><strong>3.static</strong></p> <pre><code>1、创建独立于对象的域变量或者方法

2、修饰成员、成员方法、代码块、静态内部类

3、类加载时就会加载被static修饰的部分，JVM会为静态变量分配内存空间

4、静态方法可以访问静态的变量，不能访问非静态的；非静态的可以访问静态的
</code></pre> <p><strong>4.final</strong></p> <pre><code>1.修饰类，这个类不能被继承

2、修饰方法，这个方法不能被重写
	一个类的private方法会隐式的指定为final方法
	如果父类有final方法，子类不能去重写
	
3.修饰成员变量，必须要赋初始值，而且只能初始化一次
	被final修饰的成员变量赋值两种方式：（1）直接赋值（2）在构造方法中赋初始值
	如果修饰的成员变量是基本类型，那么这个变量的值不能改变
	如果修饰的是引用类型，那么表示引用地址不能改变，引用指向的对象的内容还是可以改变的
</code></pre> <p><strong>5.transient</strong></p> <pre><code>关于对象序列化，类实现serializable接口
	对象转成字节序列，序列化后的对象可以写入到数据库或文件中，网络传输
	反序列化，序列化后的字节序列恢复原先的Java对象
	
transient：让对象中的某些成员变量属性不被序列化
	不需要被保存，节省存储空间
</code></pre> <p><strong>6.反射</strong></p> <pre><code>定义：
	在运行状态中，对于任意的一个类，能够知道这个了类的所有属性和方法；对于任何一个对象，都能调用它的任意方法和属性；这种动态获取类信息及动态调用对象的方法功能称之为Java的反射机制。

原理：
	Class.forName(&quot;c.a.xxx&quot;);
		java.lang.Class的静态方法，获取类信息
	Class&lt;?&gt; caller = Reflection.getCallerClass();
		通过反射，获取调用进来的类信息，从而获取当前的classLoader
	forName0(className, true, ClassLoader.getClassLoader(caller), caller)
		调用native方法，获取class信息
</code></pre> <p><strong>7.抽象类与接口</strong></p> <pre><code>定义本身：
	接口是完全抽象的；抽象类是半抽象的；（体现在接口中的方法只有名，没有具体实现；java8有了default方法；抽象类可以有具体方法）
	
	抽象类的成员变量可以是各种类型，而接口中的成员变量只能是public static final
	
使用：
	一个类只能继承一个抽象类，但可以实现多个接口
	抽象类像一个模板，接入像一个行为规范
</code></pre> <h2 id="三、集合">三、集合</h2> <blockquote><p>ArrayList、 LinkedList</p> <p>HashMap、</p> <p>ConcurrentHashMap</p> <p>​	锁分段技术
​	读是否加锁，why
​	迭代器是强一致性还是弱一致性的迭代器</p> <p>HashSet</p> <p>set如何保证不重复</p> <p>concurrentHashMap内部原理，如何保证线程安全</p></blockquote> <h2 id="四、io">四、IO</h2> <ul><li>HTTP/tcp/udp网络协议原理</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>HTTP协议是构建在tcp/ip协议之上的，是tcp/ip协议的一个子集；

tcp/ip协议族四层协议：
    应用层：HTTP、FTP、DNS等
    传输层：TCP、UDP
    网络层：处理网络上流动的数据包
    数据链路层：处理连接网络的硬件部分
   
TCP三次握手：
	1）客户端发送SYN标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认
	2）服务端接收到客户端的SYN报文段后，需要发送ACK信息对这个SYN报文段进行确认；同时，是要发送自己的SYN请求信息，服务端会将上述信息放到一个报文段（SYN+ACK报文段）中，一并发送给客户端，此时，服务端进入SYN_RECV状态
	3）客户端收到服务端的SYN+ACK报文段后，会向服务端发送ACK确认报文段，这个报文段发送完毕，客户端和服务端都进入ESTABLISHED状态，完成TCP三次握手
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><ul><li><p>BIO</p> <p>同步阻塞IO</p></li> <li><p>NIO</p></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>同步非阻塞IO
	
核心类：
	1.Channel(通道) 
		特性：
			双向性
			非阻塞性
			操作唯一性 （通过buffer操作）
		实现：
	2.Buffer
		作用：读写Channel中的数据
		本质：一块内存区域
		属性：
			Capacity（容量）
			Position（位置）
			limit（上限）
			Mark（标记）
	3.Selector
		
步骤：
	1）创建Selector
	2）通过ServerSocketChannel创建Channel通道
	3）为channel通道绑定监听端口
	4）设置channel为非阻塞模式
	5）将channel注册到selector上，监听连接事件
	6）循环等待新的连接
	7）根据就绪状态，调用对应的方法处理业务逻辑
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><ul><li><p>netty</p> <p>netty封装了JDK的NIO，是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端</p></li></ul> <h2 id="五、java并发">五、java并发</h2> <p><strong>sleep与wait</strong>：</p> <pre><code>Thread.sleep() 释放CPU资源，不释放锁

Object.wait() 释放锁，需要notify唤醒线程，重新获取锁；
</code></pre> <p><strong>notify与notifyall</strong>：</p> <pre><code>notify唤醒一个线程，并允许它去获取锁

notifyall唤醒所有等待这个对象的线程，允许他们去获取对象锁；

//注意：如果要把notify和wait方法放在一起用的话，必须先调用notify后调用wait，因为如果调用完wait，该线程就已经不是current thread了。
</code></pre> <p><strong>Synchronized与volatile</strong>：</p> <pre><code> Synchronized：

	同步方法：线程A调用加锁的A方法，或得到对象锁，等A方法执行完，其他线程才能调用A方法
	同步代码块：缩小同步范围，提高执行效率，可指定锁对象	
	加到static方法给class类上锁，加到非静态方法是给对象上锁
	锁重入：线程得到对象锁后，再次请求此对象锁，可再次得到；在Synchronized方法内部再次调用其他

 volatile：

	修饰变量，保证最新；
	使变量在多个线程间可见；强制从公共堆栈取得变量值，而不是从线程私有数据栈取值
</code></pre> <p><strong>同步锁，互斥锁</strong></p> <blockquote></blockquote> <p><strong>join方法</strong>：</p> <pre><code>等待子线程终止；

join方法的原理就是调用wait方法进行等待操作，子线程执行完JVM会自动调用notify方法唤醒主线程，主线程继续执行；
</code></pre> <p><strong>线程的状态</strong></p> <blockquote><p>新建、就绪、运行、阻塞、死亡</p></blockquote> <p><strong>ReentrantLock</strong></p> <p><strong>Lock接口和Synchronized比较</strong></p> <p><strong>ThreadLocal,ThreadLocalMap</strong></p> <blockquote><p>ThreadLocal为每一个线程提供独立的变量副本，隔离了多个线程对数据的访问冲突；</p></blockquote> <p><strong>submit和excute</strong></p> <p><strong>FutureTask</strong></p> <p><strong>乐观锁和悲观锁</strong></p> <p><strong>死锁</strong></p> <p><strong>分布式锁有哪些，怎么实现的</strong></p> <p><strong>cas</strong></p> <h2 id="六、事务">六、事务</h2> <p><strong>数据库事务隔离级别</strong></p> <pre><code>1.读未提交；导致脏读

2.读提交；不可重复读，幻读

3.重复读；多次读是一致的

4.串行化；所有事务串行执行
</code></pre> <p><strong>读写锁</strong></p> <p><strong>事务管理器</strong></p> <p><strong>声明式事务实现原理：</strong></p> <p><strong>如何回滚事务</strong>：</p> <blockquote><p>在上下文正在执行的代码中出现异常，事务代码会捕获异常，做出回滚决定</p></blockquote> <h2 id="七、jvm">七、JVM</h2> <p><strong>Java定位内存溢出</strong></p> <h2 id="八、中间件">八、中间件</h2> <p><strong>1.Tomcat实现原理</strong></p> <pre><code>Tomcat容器运行机制
类加载机制
核心组件
Tomcat优化
</code></pre> <p><strong>2.集群数据库同步问题</strong></p> <p><strong>3.消息队列</strong></p> <pre><code>disruptor单机性能最高的MQ，600w QPS/sec
</code></pre> <h2 id="九、jdk源码">九、jdk源码</h2> <h3 id="_1-锁的设计与实现">1.锁的设计与实现</h3> <p><strong>锁的特性</strong></p> <blockquote><p>1.排他性（互斥） -- 》跨线程可见性</p> <p>2.公平性与非公平性（是否可以不排队）</p> <p>3.没有获得锁的线程等待（阻塞）</p> <p>4.锁的获得和释放的方法</p> <p>5.是否支持重入（避免死锁）</p> <p>6.锁的作用范围（控制粒度提升性能）</p></blockquote> <p><strong>锁的状态</strong></p> <blockquote><p>偏向锁（是否有存在的必要？） -》 开关（允许关闭或打开）</p> <p>​	通过cas的方式，把当前锁偏向于线程A</p> <p>​	同一时间只有一个线程来访问</p> <p>轻量级锁</p> <p>​	背景：在大多数情况下，线程获得和释放锁的时间很短</p> <p>​	竞争不是特别激烈的情况</p> <p>​	自旋锁的方式去尝试获得锁</p> <p>​	临界点：CPU的资源开销</p> <p>重量级锁 -》比较耗性能</p> <p>​	竞争很激烈</p> <p>​	self-&gt;_ParkEvent-&gt;park();</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">10/20/2019, 9:26:23 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/share/es.html" class="prev">
          ElasticSearch
        </a></span> <span class="next"><a href="/blog/share/spring.html">
          Spring
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.3e99f69d.js" defer></script><script src="/blog/assets/js/2.1d01ac6d.js" defer></script><script src="/blog/assets/js/24.cca64a4b.js" defer></script>
  </body>
</html>
