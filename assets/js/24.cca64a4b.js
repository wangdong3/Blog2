(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{224:function(n,t,s){"use strict";s.r(t);var a=s(0),e=Object(a.a)({},function(){var n=this,t=n.$createElement,s=n._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"知识点"}},[n._v("知识点")]),n._v(" "),s("h2",{attrs:{id:"一、计算机基础"}},[n._v("一、计算机基础")]),n._v(" "),s("p",[s("strong",[n._v("机器数: 原码 补码 反码")])]),n._v(" "),s("blockquote",[s("p",[n._v("练习： [x]补=1 1110100， [y]补=10110000。若整型变量 z=2*x+y/2，则 z 的机器数为（ ）。")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("第一步：根据补码算反码（正数的补码与其原码相同；负数的补码是在其反码的末位加1）\n\n反码: x: 11110011   y: 10101111\n\n第二步：根据反码算原码（正数的反码与其原码相同；负数的反码是对其原码逐位取反，符号位除外）\n\n原码: x: 10001100   y: 11010000\n\n第三步：分别计算2*x和y/2\n\n10001100 向左移一位\n2*x =  10011000\n\n11010000  向右移一位\ny/2 = 10101000\n\n第四步：计算2*x+y/2\n\n10011000\n+  10101000\n\nz=2*x+y/2 = 11000000\n\n\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br")])]),s("h2",{attrs:{id:"二、java基础"}},[n._v("二、Java基础")]),n._v(" "),s("p",[s("strong",[n._v("1.String")]),n._v(" :")]),n._v(" "),s("pre",[s("code",[n._v("1.String常量池：字符串常量放在常量池中实现复用，指向常量池中同一个内存地址；\n\n2.为什么String是不可变的：成员变量final，并且没有set方法来修改\n")])]),n._v(" "),s("p",[s("strong",[n._v("2.new")]),n._v("：")]),n._v(" "),s("pre",[s("code",[n._v("创建新的对象，指向全新的内存地址；\n\nString类的intern方法创建返回一个常量池中的固定对象\n")])]),n._v(" "),s("p",[s("strong",[n._v("3.static")])]),n._v(" "),s("pre",[s("code",[n._v("1、创建独立于对象的域变量或者方法\n\n2、修饰成员、成员方法、代码块、静态内部类\n\n3、类加载时就会加载被static修饰的部分，JVM会为静态变量分配内存空间\n\n4、静态方法可以访问静态的变量，不能访问非静态的；非静态的可以访问静态的\n")])]),n._v(" "),s("p",[s("strong",[n._v("4.final")])]),n._v(" "),s("pre",[s("code",[n._v("1.修饰类，这个类不能被继承\n\n2、修饰方法，这个方法不能被重写\n\t一个类的private方法会隐式的指定为final方法\n\t如果父类有final方法，子类不能去重写\n\t\n3.修饰成员变量，必须要赋初始值，而且只能初始化一次\n\t被final修饰的成员变量赋值两种方式：（1）直接赋值（2）在构造方法中赋初始值\n\t如果修饰的成员变量是基本类型，那么这个变量的值不能改变\n\t如果修饰的是引用类型，那么表示引用地址不能改变，引用指向的对象的内容还是可以改变的\n")])]),n._v(" "),s("p",[s("strong",[n._v("5.transient")])]),n._v(" "),s("pre",[s("code",[n._v("关于对象序列化，类实现serializable接口\n\t对象转成字节序列，序列化后的对象可以写入到数据库或文件中，网络传输\n\t反序列化，序列化后的字节序列恢复原先的Java对象\n\t\ntransient：让对象中的某些成员变量属性不被序列化\n\t不需要被保存，节省存储空间\n")])]),n._v(" "),s("p",[s("strong",[n._v("6.反射")])]),n._v(" "),s("pre",[s("code",[n._v('定义：\n\t在运行状态中，对于任意的一个类，能够知道这个了类的所有属性和方法；对于任何一个对象，都能调用它的任意方法和属性；这种动态获取类信息及动态调用对象的方法功能称之为Java的反射机制。\n\n原理：\n\tClass.forName("c.a.xxx");\n\t\tjava.lang.Class的静态方法，获取类信息\n\tClass<?> caller = Reflection.getCallerClass();\n\t\t通过反射，获取调用进来的类信息，从而获取当前的classLoader\n\tforName0(className, true, ClassLoader.getClassLoader(caller), caller)\n\t\t调用native方法，获取class信息\n')])]),n._v(" "),s("p",[s("strong",[n._v("7.抽象类与接口")])]),n._v(" "),s("pre",[s("code",[n._v("定义本身：\n\t接口是完全抽象的；抽象类是半抽象的；（体现在接口中的方法只有名，没有具体实现；java8有了default方法；抽象类可以有具体方法）\n\t\n\t抽象类的成员变量可以是各种类型，而接口中的成员变量只能是public static final\n\t\n使用：\n\t一个类只能继承一个抽象类，但可以实现多个接口\n\t抽象类像一个模板，接入像一个行为规范\n")])]),n._v(" "),s("h2",{attrs:{id:"三、集合"}},[n._v("三、集合")]),n._v(" "),s("blockquote",[s("p",[n._v("ArrayList、 LinkedList")]),n._v(" "),s("p",[n._v("HashMap、")]),n._v(" "),s("p",[n._v("ConcurrentHashMap")]),n._v(" "),s("p",[n._v("​\t锁分段技术\n​\t读是否加锁，why\n​\t迭代器是强一致性还是弱一致性的迭代器")]),n._v(" "),s("p",[n._v("HashSet")]),n._v(" "),s("p",[n._v("set如何保证不重复")]),n._v(" "),s("p",[n._v("concurrentHashMap内部原理，如何保证线程安全")])]),n._v(" "),s("h2",{attrs:{id:"四、io"}},[n._v("四、IO")]),n._v(" "),s("ul",[s("li",[n._v("HTTP/tcp/udp网络协议原理")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("HTTP协议是构建在tcp/ip协议之上的，是tcp/ip协议的一个子集；\n\ntcp/ip协议族四层协议：\n    应用层：HTTP、FTP、DNS等\n    传输层：TCP、UDP\n    网络层：处理网络上流动的数据包\n    数据链路层：处理连接网络的硬件部分\n   \nTCP三次握手：\n\t1）客户端发送SYN标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认\n\t2）服务端接收到客户端的SYN报文段后，需要发送ACK信息对这个SYN报文段进行确认；同时，是要发送自己的SYN请求信息，服务端会将上述信息放到一个报文段（SYN+ACK报文段）中，一并发送给客户端，此时，服务端进入SYN_RECV状态\n\t3）客户端收到服务端的SYN+ACK报文段后，会向服务端发送ACK确认报文段，这个报文段发送完毕，客户端和服务端都进入ESTABLISHED状态，完成TCP三次握手\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br")])]),s("ul",[s("li",[s("p",[n._v("BIO")]),n._v(" "),s("p",[n._v("同步阻塞IO")])]),n._v(" "),s("li",[s("p",[n._v("NIO")])])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("同步非阻塞IO\n\t\n核心类：\n\t1.Channel(通道) \n\t\t特性：\n\t\t\t双向性\n\t\t\t非阻塞性\n\t\t\t操作唯一性 （通过buffer操作）\n\t\t实现：\n\t2.Buffer\n\t\t作用：读写Channel中的数据\n\t\t本质：一块内存区域\n\t\t属性：\n\t\t\tCapacity（容量）\n\t\t\tPosition（位置）\n\t\t\tlimit（上限）\n\t\t\tMark（标记）\n\t3.Selector\n\t\t\n步骤：\n\t1）创建Selector\n\t2）通过ServerSocketChannel创建Channel通道\n\t3）为channel通道绑定监听端口\n\t4）设置channel为非阻塞模式\n\t5）将channel注册到selector上，监听连接事件\n\t6）循环等待新的连接\n\t7）根据就绪状态，调用对应的方法处理业务逻辑\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br")])]),s("ul",[s("li",[s("p",[n._v("netty")]),n._v(" "),s("p",[n._v("netty封装了JDK的NIO，是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端")])])]),n._v(" "),s("h2",{attrs:{id:"五、java并发"}},[n._v("五、java并发")]),n._v(" "),s("p",[s("strong",[n._v("sleep与wait")]),n._v("：")]),n._v(" "),s("pre",[s("code",[n._v("Thread.sleep() 释放CPU资源，不释放锁\n\nObject.wait() 释放锁，需要notify唤醒线程，重新获取锁；\n")])]),n._v(" "),s("p",[s("strong",[n._v("notify与notifyall")]),n._v("：")]),n._v(" "),s("pre",[s("code",[n._v("notify唤醒一个线程，并允许它去获取锁\n\nnotifyall唤醒所有等待这个对象的线程，允许他们去获取对象锁；\n\n//注意：如果要把notify和wait方法放在一起用的话，必须先调用notify后调用wait，因为如果调用完wait，该线程就已经不是current thread了。\n")])]),n._v(" "),s("p",[s("strong",[n._v("Synchronized与volatile")]),n._v("：")]),n._v(" "),s("pre",[s("code",[n._v(" Synchronized：\n\n\t同步方法：线程A调用加锁的A方法，或得到对象锁，等A方法执行完，其他线程才能调用A方法\n\t同步代码块：缩小同步范围，提高执行效率，可指定锁对象\t\n\t加到static方法给class类上锁，加到非静态方法是给对象上锁\n\t锁重入：线程得到对象锁后，再次请求此对象锁，可再次得到；在Synchronized方法内部再次调用其他\n\n volatile：\n\n\t修饰变量，保证最新；\n\t使变量在多个线程间可见；强制从公共堆栈取得变量值，而不是从线程私有数据栈取值\n")])]),n._v(" "),s("p",[s("strong",[n._v("同步锁，互斥锁")])]),n._v(" "),s("blockquote"),n._v(" "),s("p",[s("strong",[n._v("join方法")]),n._v("：")]),n._v(" "),s("pre",[s("code",[n._v("等待子线程终止；\n\njoin方法的原理就是调用wait方法进行等待操作，子线程执行完JVM会自动调用notify方法唤醒主线程，主线程继续执行；\n")])]),n._v(" "),s("p",[s("strong",[n._v("线程的状态")])]),n._v(" "),s("blockquote",[s("p",[n._v("新建、就绪、运行、阻塞、死亡")])]),n._v(" "),s("p",[s("strong",[n._v("ReentrantLock")])]),n._v(" "),s("p",[s("strong",[n._v("Lock接口和Synchronized比较")])]),n._v(" "),s("p",[s("strong",[n._v("ThreadLocal,ThreadLocalMap")])]),n._v(" "),s("blockquote",[s("p",[n._v("ThreadLocal为每一个线程提供独立的变量副本，隔离了多个线程对数据的访问冲突；")])]),n._v(" "),s("p",[s("strong",[n._v("submit和excute")])]),n._v(" "),s("p",[s("strong",[n._v("FutureTask")])]),n._v(" "),s("p",[s("strong",[n._v("乐观锁和悲观锁")])]),n._v(" "),s("p",[s("strong",[n._v("死锁")])]),n._v(" "),s("p",[s("strong",[n._v("分布式锁有哪些，怎么实现的")])]),n._v(" "),s("p",[s("strong",[n._v("cas")])]),n._v(" "),s("h2",{attrs:{id:"六、事务"}},[n._v("六、事务")]),n._v(" "),s("p",[s("strong",[n._v("数据库事务隔离级别")])]),n._v(" "),s("pre",[s("code",[n._v("1.读未提交；导致脏读\n\n2.读提交；不可重复读，幻读\n\n3.重复读；多次读是一致的\n\n4.串行化；所有事务串行执行\n")])]),n._v(" "),s("p",[s("strong",[n._v("读写锁")])]),n._v(" "),s("p",[s("strong",[n._v("事务管理器")])]),n._v(" "),s("p",[s("strong",[n._v("声明式事务实现原理：")])]),n._v(" "),s("p",[s("strong",[n._v("如何回滚事务")]),n._v("：")]),n._v(" "),s("blockquote",[s("p",[n._v("在上下文正在执行的代码中出现异常，事务代码会捕获异常，做出回滚决定")])]),n._v(" "),s("h2",{attrs:{id:"七、jvm"}},[n._v("七、JVM")]),n._v(" "),s("p",[s("strong",[n._v("Java定位内存溢出")])]),n._v(" "),s("h2",{attrs:{id:"八、中间件"}},[n._v("八、中间件")]),n._v(" "),s("p",[s("strong",[n._v("1.Tomcat实现原理")])]),n._v(" "),s("pre",[s("code",[n._v("Tomcat容器运行机制\n类加载机制\n核心组件\nTomcat优化\n")])]),n._v(" "),s("p",[s("strong",[n._v("2.集群数据库同步问题")])]),n._v(" "),s("p",[s("strong",[n._v("3.消息队列")])]),n._v(" "),s("pre",[s("code",[n._v("disruptor单机性能最高的MQ，600w QPS/sec\n")])]),n._v(" "),s("h2",{attrs:{id:"九、jdk源码"}},[n._v("九、jdk源码")]),n._v(" "),s("h3",{attrs:{id:"_1-锁的设计与实现"}},[n._v("1.锁的设计与实现")]),n._v(" "),s("p",[s("strong",[n._v("锁的特性")])]),n._v(" "),s("blockquote",[s("p",[n._v("1.排他性（互斥） -- 》跨线程可见性")]),n._v(" "),s("p",[n._v("2.公平性与非公平性（是否可以不排队）")]),n._v(" "),s("p",[n._v("3.没有获得锁的线程等待（阻塞）")]),n._v(" "),s("p",[n._v("4.锁的获得和释放的方法")]),n._v(" "),s("p",[n._v("5.是否支持重入（避免死锁）")]),n._v(" "),s("p",[n._v("6.锁的作用范围（控制粒度提升性能）")])]),n._v(" "),s("p",[s("strong",[n._v("锁的状态")])]),n._v(" "),s("blockquote",[s("p",[n._v("偏向锁（是否有存在的必要？） -》 开关（允许关闭或打开）")]),n._v(" "),s("p",[n._v("​\t通过cas的方式，把当前锁偏向于线程A")]),n._v(" "),s("p",[n._v("​\t同一时间只有一个线程来访问")]),n._v(" "),s("p",[n._v("轻量级锁")]),n._v(" "),s("p",[n._v("​\t背景：在大多数情况下，线程获得和释放锁的时间很短")]),n._v(" "),s("p",[n._v("​\t竞争不是特别激烈的情况")]),n._v(" "),s("p",[n._v("​\t自旋锁的方式去尝试获得锁")]),n._v(" "),s("p",[n._v("​\t临界点：CPU的资源开销")]),n._v(" "),s("p",[n._v("重量级锁 -》比较耗性能")]),n._v(" "),s("p",[n._v("​\t竞争很激烈")]),n._v(" "),s("p",[n._v("​\tself->_ParkEvent->park();")])])])},[],!1,null,null,null);t.default=e.exports}}]);